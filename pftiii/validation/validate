#!/bin/bash
################################################################################
# Proprietary Fingerprint Template III Validation                              #
#                                                                              #
# Place your properly-named library in to lib/ and then execute this script.   #
# If your implementation meets the tested requirements, an archive will be     #
# created for you to send to NIST for evaluation. The output of your           #
# implementation on your hardware must match the output generated at NIST      #
# exactly, so "forcing" the creation of the archive will not speed along your  #
# evaluation results.                                                          #
#                                                                              #
#  E-mail: pft@nist.gov                                                        #
#     URL: https://github.com/usnistgov/pft                                    #
# License: This software was developed at the National Institute of Standards  #
#          and Technology (NIST) by employees of the Federal Government in the #
#          course of their official duties.  Pursuant to title 17 Section 105  #
#          of the United States Code, this software is not subject to          #
#          copyright protection and is in the public domain.  NIST assumes no  #
#          responsibility whatsoever for its use by other parties, and makes   #
#          no guarantees, expressed or implied, about its quality,             #
#          reliability, or any other characteristic.                           #
################################################################################

################################################################################
# Constants                                                                    #
################################################################################

# Time in seconds when this script was launched
start_sec="$(date +%s)"

# URL where the complete validation package can be downloaded
validation_dl_url="https://github.com/usnistgov/pft/releases"
# URL where the validation imagery is requested
validation_image_request_url="https://nigos.nist.gov/datasets/"
validation_image_request_url+="pftiii_validation/request"

# Directory containing validation materials
wd="$(cd "$(dirname "${0}")" && pwd)"
# Directory containing validation images
validation_image_dir="images"
# Directory where libraries go
lib_dir="${wd}"/lib
local_lib_dir="${lib_dir}"
# Directory where validation driver sourcecode lives
src_dir="${wd}"/src
# Directory where validation driver build files reside
build_dir="${src_dir}/build"
# Directory where validation driver executable is installed
bin_dir="${wd}"/bin
# Output directory for validation driver logs
output_dir="${wd}"/output
# Configuration directory provided to PFTIII::Interface implementation
config_dir="${wd}"/config
local_config_dir="${config_dir}"
# Path to the compiled validation driver binary
binary="${bin_dir}/pftiii_validation"
# Suffix given to files set aside by this script
move_suffix=".moved"

# Symbol name for function that creates proprietary templates
create_func="createProprietaryTemplate"
# Symbol name for function that compares two proprietary templates
compare_func="compareProprietaryTemplates"
# Prefix for downloaded validation imagery tarballs
validation_image_download_prefix=pftiii_validation_images

################################################################################
# Functions                                                                    #
################################################################################

# Dimmed text color
font_dim() { if [ -t 1 ]; then tput dim; fi }
# Green text color
font_green() { if [ -t 1 ]; then tput setaf 2; fi }
# Red text color
font_red() { if [ -t 1 ]; then tput setaf 1; fi }
# Light red text color
font_lightred() { if [ -t 1 ]; then tput setaf 5; fi }
# Yellow text color
font_yellow() { if [ -t 1 ]; then tput setaf 3; fi }
# Underline the text
font_underline() { if [ -t 1 ]; then tput smul; fi }
# Reset to default text color
font_reset() { if [ -t 1 ]; then tput sgr0; fi }

# Print the path of the argument relative to the current working directory
rp()
{
	realpath=realpath
	if [ "$(uname)" == "Darwin" ]; then
		realpath="/opt/local/bin/grealpath"
	fi

	${realpath} --relative-to="${PWD}" "${1}"
}

# Output string in a box
box()
{
	if [ "${#}" -lt 1 ] || [ "${#}" -gt 7 ] ; then
		echo -n "Usage: ${FUNCNAME[0]} <msg> [width=80] "
		echo "[tb_symbol='='] [lr_symbol='|'] [align=[a|l|c|r]] "
		echo "[header=0|1] [footer=0|1]"
		return 1
	fi
	local msg="${1}"
	local width=80
	if [ "${#}" -ge 2 ]; then
		width="${2}"
	fi
	local tb_symbol='='
	if [ "${#}" -ge 3 ]; then
		tb_symbol="${3}"
		if [ "${#tb_symbol}" -ne 1 ]; then
			echo "tb_symbol not a single character"
			return 1
		fi
	fi
	local lr_symbol='|'
	if [ "${#}" -ge 4 ]; then
		lr_symbol="${4}"
		if [ "${#lr_symbol}" -ne 1 ]; then
			echo "lr_symbol not a single character"
			return 1
		fi
	fi
	local align="a"
	if [ "${#}" -ge 5 ]; then
		align="${5}"
		if [ "${align}" != "c" ] && [ "${align}" != "a" ] && \
		    [ "${align}" != "l" ] && [ "${align}" != "r" ]; then
			echo "Invalid alignment value"
			return 1
		fi
	fi
	local print_header=1
	if [ "${#}" -ge 6 ]; then
		print_header="${6}"
		if [ "${print_header}" -ne 0 ] && [ "${print_header}" -ne 1 ]
		then
			echo "Invalid print_header value"
		fi
	fi
	local print_footer=1
	if [ "${#}" -eq 7 ]; then
		print_footer="${7}"
		if [ "${print_footer}" -ne 0 ] && [ "${print_footer}" -ne 1 ]
		then
			echo "Invalid print_footer value"
		fi
	fi

	if [ "${print_header}" -eq 1 ]; then
		printline "${tb_symbol}" "${width}" && echo
	fi

	local max_width=$(( width - 4 ))

	# Center align if a single line and alignment is auto
	if [ "${align}" == "a" ]; then
		if [ "${#msg}" -le "${max_width}" ]; then
			align="c"
		else
			align="l"
		fi
	fi

	local num_chars
	local indent_count
	local indent_pre
	local indent_post
	while read -r line; do
		num_chars="${#line}"
		indent_count=$(( (max_width + 2) - num_chars ))

		if [ "${align}" == "c" ]; then
			indent_pre=$(( indent_count / 2 ))
			indent_post=$(( (indent_count + 2 - 1) / 2 ))
		elif [ "${align}" == "l" ]; then
			indent_pre=1
			indent_post=$(( indent_count - 1 ))
		elif [ "${align}" == "r" ]; then
			indent_pre=$(( indent_count - 1 ))
			indent_post=1
		fi

		# Left (floor)
		echo -n "${lr_symbol}"
		for i in $(seq 1 "${indent_pre}"); do
			echo -n ' '
		done

		# Message
		echo -n "${line}"

		# Right (ceiling)
		for i in $(seq 1 "${indent_post}"); do
			echo -n ' '
		done

		echo "${lr_symbol}"
	done < <(printf "%b\n" "${msg}" | fold -s -w "${max_width}")

	if [ "${print_footer}" -eq 1 ]; then
		printline "${tb_symbol}" "${width}" && echo
	fi
}

# Print validation script header message
print_header()
{
	box "PFT III Validation | Version ${validation_version} | $(get_date)"
}

# Print validation script footer message
print_footer()
{
	local start_sec
	if [ "${#}" -eq 1 ]; then
		start_sec="${1}"
	fi

	font_reset
	font_dim
	echo -n "Completed: $(get_date)"
	if [ "${start_sec}" != "" ]; then
		local duration=$(( "$(date +%s)" - start_sec ))
		echo " (Runtime: ${duration}s)"
	else
		echo
	fi
	font_reset
}

# Convenience for a middle line with 80 char left align standard box
# shellcheck disable=SC2120
boxline()
{
	if [ "${#}" -eq 0 ]; then
		box "" 80 '=' '|' 'l' 0 0
	else
		for i in "${@}"; do
			box "${i}" 80 '=' '|' 'l' 0 0
		done
	fi
}

# Convenience function to print a failure method and exit
# All params are echoed in a box with newlines in between.
fail()
{
	font_red
	echo "[FAIL]"
	echo

	if [ "${#}" -eq 1 ]; then
		box "${1}" 80 '!' '!'
	elif [ "${#}" -gt 1 ]; then
		for i in $(seq 1 "${#}"); do
			if [ "${i}" -eq 1 ]; then
				box "${!i}" 80 '!' '!' 'l' 1 0
			elif [ "${i}" -eq "${#}" ]; then
				box "${!i}" 80 '!' '!' 'l' 0 1
			else
				box "${!i}" 80 '!' '!' 'l' 0 0
			fi
		done
	fi

	if ! move_back_dirs; then
		echo
		local msg="Additionally, this script could not move back your "
		msg+="renamed lib and/or config directories. They may be named "
		msg+="$(rp "${local_lib_dir}${move_suffix}") and "
		msg+="$(rp "${local_config_dir}${move_suffix}") respectfully."
		box "${msg}" 80 '!' '!' 'l'
	fi

	font_reset

	print_footer "${start_sec}"

	# Exit from here
	exit 1
}

# Print [WARN] with any arguments in a box after.
# All params are echoed in a box with newlines in between.
warn()
{
	font_lightred
	echo "[WARN]"


	if [ "${#}" -eq 1 ]; then
		echo
		box "${1}"
	elif [ "${#}" -gt 1 ]; then
		echo
		for i in $(seq 1 "${#}"); do
			if [ "${i}" -eq 1 ]; then
				box "${!i}" 80 '=' '|' 'l' 1 0
			elif [ "${i}" -eq "${#}" ]; then
				box "${!i}" 80 '=' '|' 'l' 0 1
			else
				box "${!i}" 80 '=' '|' 'l' 0 0
			fi
		done
	fi

	font_reset
}

# Print [OKAY] with any arguments in parenthesis before.
okay()
{
	if [ $# -ne 0 ]; then
		for i in "${@}"; do
			font_dim
			echo -n "(${i}) "
			font_reset
		done
	fi
	font_green
	echo "[OKAY]"
	font_reset
}

# Print a repeated line
printline()
{
	if [ $# -ne 2 ]; then
		echo "Usage: ${FUNCNAME[0]} <char> <times>"
		return 1
	fi

	printf "${1}%.0s" $(seq 1 "${2}")
}

# Check that images have been downloaded, placed in the correct spot, etc.
check_for_images()
{
	# Check for data
	echo -n "Checking for validation images... "
	if ! [ -d "${wd}"/${validation_image_dir} ]; then
		# If directory doesn't exist, maybe user didn't expand archive
		local image_archive
		image_archive=$(ls -r \
		    "${wd}"/${validation_image_download_prefix}* 2> /dev/null)
		if [ "${image_archive}" != "" ]; then
			font_yellow
			echo "[DEFER]"
			font_reset
			for i in $(find "${wd}" -maxdepth 1 -name \
			    "${validation_image_download_prefix}*" | sort); do
				echo -n "Expanding $(basename "${i}")... "
				if ! tar xf "${i}" > /dev/null 2>&1; then
					fail "Failed to expand ${i}"
				else
					okay
				fi
			done

			check_for_images
			return
		else
			msg="Cannot find validation images. You must request "
			msg+="them from NIST's website and place them within:"
			fail "${msg}" "${wd}" "The URL is:" \
			    ${validation_image_request_url}
		fi
	else
		# If the directory does exist, check that every archive present
		# has been expanded
		local has_deferred=0
		while read -r i; do
		    	local regex=".*\/${validation_image_download_prefix}"
		    	regex+="\(.*\)-.\+.tar.gz"
			if ! [ -e "${wd}"/${validation_image_dir}/VERSION ];
			    then
			    	if [ $has_deferred -eq 0 ]; then
			    		font_yellow
	    				echo -n "[DEFER]"
	    				font_reset
	    				has_deferred=1
	    			fi

				echo -n "Expanding $(basename "${i}")... "
				if ! tar xf "${i}" > /dev/null 2>&1; then
					fail "Failed to expand ${i}"
				else
					okay
					return
				fi
			fi
		done < <(find "${wd}" -maxdepth 1 -name \
		    "${validation_image_download_prefix}*")
	fi

	okay
}

# Ensure that the imagery versions downloaded are compatible with this
# version of the validation script.
check_image_versions()
{
	# Version of image dataset compatible with this script
	local expected_image_version="201912181310"

	echo -n "Checking validation image versions... "

	if ! [ -e "${wd}"/${validation_image_dir}/VERSION ]; then
		msg="No images were found within within ${wd}/"
		msg+="${validation_image_dir}.  If you have images, please "
		msg+="move them to the appropriate location. If you don't have "
		msg+="images, please request the latest versions from NIST: "
		fail "${msg}" ${validation_image_request_url}
	fi

	local image_version="UNKNOWN"
	read -r image_version < "${wd}"/${validation_image_dir}/VERSION
	if [ "${expected_image_version}" != "${image_version}" ]; then
		msg="The version of validation images within ${wd}/"
		msg+="${validation_image_dir} (${image_version}) is not "
		msg+="compatible with this version of the validation script "
		msg+="(${validation_version}). Please request the latest "
		msg+="version from the NIST website: "
		fail "${msg}" ${validation_image_request_url}
	fi

	okay
}

move_back_dirs()
{
	local rv=0

	local original_path
	original_path="$(dirname "${local_lib_dir}")/"
	original_path+="$(basename "${local_lib_dir}" "${move_suffix}")"
	if ! [ -d "${original_path}" ]; then
		if mv -n "${local_lib_dir}" "${original_path}" > \
		     /dev/null 2>&1
		then
			local_lib_dir="${original_path}"
		else
			rv=1
		fi
	fi

	original_path="$(dirname "${local_config_dir}")/"
	original_path+="$(basename "${local_config_dir}" "${move_suffix}")"
	if ! [ -d "${original_path}" ]; then
		if mv -n "${local_config_dir}" "${original_path}" > \
		   /dev/null 2>&1
		then
			local_config_dir="${original_path}"
		else
			rv=1
		fi
	fi

	return "${rv}"
}

# Record MD5 of randomly-generated files to ensure that you truly have the
# latest version of the validation imagery
log_canaries()
{
	local canary_prefix="canary"
	find -L "${wd}"/${validation_image_dir} -name "${canary_prefix}*" \
	    -exec md5sum {} \; >> "${output_dir}"/canary.log
}

# Check that Ubuntu packages used in this file have been installed.
check_required_packages()
{
	echo -n "Checking for required packages... "

	# Packages required to run this script
	local pkgs="base-files binutils cmake coreutils curl file findutils "
	pkgs+="g++ gawk grep libc-bin make sed tar xz-utils"

	if ! command -v dpkg-query > /dev/null; then
		local msg="\`dpkg-query' is required to be installed for "
		msg+="validation. Try \`apt install dpkg' to install."
		fail "${msg}"
	fi

	for pkg in ${pkgs}; do
		if ! dpkg-query -l "${pkg}" > /dev/null 2>&1; then
			msg="The required package \"${pkg}\" was not "
			msg+="installed. Try \`apt install ${pkg}\` to install "
			msg+="\"${pkg}.\""
			fail "${msg}"
		fi
	done

	okay
}

# If the user has Internet access, check that this script is the latest version.
# @return 1 if version could be checked, 0 if not.
check_validation_version()
{
	# URL with the most recent version number of the validation package
	local version_url="https://raw.githubusercontent.com/usnistgov/pft/"
	local version_url+="master/pftiii/validation/VERSION"
	# Confirm validation package version, if possible
	local checked=0

	echo -n "Checking validation version... "
	# d.root-servers.net -> 199.7.91.13
	if ping -W 1 -c 1 199.7.91.13 > /dev/null 2>&1; then
		local internet_version=0
		if ! internet_version=$(curl -m 10 -f "${version_url}" \
		    2>/dev/null)
		then
			font_dim
			echo -n "(connection failure) "
			font_reset
			font_yellow
			echo -n "[SKIP]"
			font_reset
		else
			if [ "${internet_version}" != "${validation_version}" ];
			then
				msg="You are running an old version of the "
				msg+="validation package (${validation_version}"
				msg+="). Please download ${internet_version} "
				msg+="from:"
				fail "${msg}" "${validation_dl_url}"
			else
				okay "${validation_version}"
				checked=1
			fi
		fi
	else
		font_dim
		echo -n "(no Internet connection) "
		font_reset
		font_yellow
		echo "[SKIP]"
		font_reset
	fi

	return ${checked}
}

# Check that the version of Ubuntu is the correct version.
check_os()
{
	local expected="24.04.3 LTS (Noble Numbat)"
	echo -n "Checking OS and version... "
	if [ ! -e /etc/os-release ]; then
		local msg="You do not appear to be using the appropriate "
		msg+="operating system. Please use Ubuntu Server ${expected}."
		fail "${msg}"
	fi
	if [ "$(grep "VERSION=" /etc/os-release | cut -f 2 -d '=' | \
	    tr -d '"')" != "${expected}" ]; then
		local msg="You do not appear to be using the appropriate "
		msg+="version of Ubuntu Server. Please use ${expected}."
		fail "${msg}"
	fi
	okay "Ubuntu Server ${expected}"
}

# Check that a core library exists
core_library_present()
{
	local lib_regex="libpftiii_[A-Za-z0-9]+_[0-9A-F]{4}.so"

	if ! [ -d "${lib_dir}" ]; then
		return 1
	fi

	local count
	count=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n" | wc -l)
	if [ "${count}" != "1" ]; then
		return 1
	fi

	return 0
}

# Get the name of the core library
get_core_library_name()
{
	if ! core_library_present; then
		return 1
	fi

	local lib_regex="libpftiii_[A-Za-z0-9]+_[0-9A-F]{4}.so"

	if ! [ -d "${lib_dir}" ]; then
		local msg="Library directory not found. Create it and place "
		msg+="the core library inside."
		fail "${msg}" "" "The library directory is:" "${lib_dir}"
	fi

	local core_lib=""
	local count
	count=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n" | wc -l)
	if [ "${count}" != "1" ]; then
		fail "More than one core library found in ${lib_dir}"
	fi

	local core_lib
	core_lib=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n")
	if [ "${core_lib}" == "" ]; then
		local msg="No core library found in the library directory. "
		msg+="Please review the PFT III library naming conventions."
		fail "${msg}" "" "The library directory is:" "${lib_dir}"
	fi

	echo "${core_lib}"
	return 0
}

# Get the name of the organization from the core library.
get_organization_name()
{
	local name
	if ! name="$(get_core_library_name)"; then
		return 1
	fi

	cut -f2 -d_ <<< "${name}"
}

# Get the version of the library from the core library.
get_lib_version()
{
	local name
	if ! name="$(get_core_library_name)"; then
		return 1
	fi

	(cut -f3 -d_ <<< "${name}") | sed 's/\(.*\).so/\1/'
}

# Ensure that a library in the lib directory implements the required naming
# convention.
check_library()
{
	echo -n "Looking for core library... "

	local core_lib=""
	if core_library_present; then
		if ! core_lib=$(get_core_library_name); then
			echo "${core_lib}"
			return 1
		fi
	else
		if ! get_core_library_name; then
                	local msg="No core library found in the library "
			msg+="directory. Please review the PFT III library "
			msg+="naming conventions."
                	fail "${msg}" "" "The library directory is:" \
			    "${lib_dir}"
		fi

		return 1
	fi

	# Some file systems are case-sensitive
	local vers
	vers="$(get_lib_version)"
	if [ "${vers}" != "$(tr '[:lower:]' '[:upper:]' <<< "${vers}")" ]; then
		local correct
		correct="$(cut -f1 -d_ <<< "${core_lib}")_"
		correct+="$(cut -f2 -d_ <<< "${core_lib}")_"
		correct+="$(tr '[:lower:]' '[:upper:]' <<< "${vers}")."
		correct+="$(cut -f2 -d. <<< "${core_lib}")"

		local msg="Please use uppercase hexadecimal digits "
		msg+="(\"ABCDEF\", not \"abcdef\") for the version in your "
		msg+="library name. Please rebuild \"${core_lib}\" as "
		msg+="\"${correct}.\""
		fail "${msg}"
	fi

	# If SONAME is present, check that it is the same as the lib name
	local SONAME
	SONAME=$(objdump -p "${lib_dir}/${core_lib}" | grep SONAME | \
	    awk '{print $2}')
	if [ "${SONAME}" != "" ]; then
		if [ "${SONAME}" != "${core_lib}" ]; then
			local msg="The SONAME of ${core_lib} is not valid. "
			msg+="${core_lib} was likely renamed after being "
			msg+="built. The SONAME must be the same name as the "
			msg+="core library."
			fail "${msg}"
		fi
	fi

	okay "${core_lib}"
}

# Check the environment for known variables, and echo them.
check_environment()
{
	echo -n "Checking for known environment variables... "
	okay
}

# Get a random number.
random_number()
{
	od -A n -t uL -N 4 /dev/urandom | tr -d -C '[:digit:]'
}

# Return "DD MMM YYYY | HH:MM:SS ZZZ"
get_date()
{
	date "+%d %b %Y | %T %Z"
}

# Check and warn if files from a previous validation attempt are still present
# in the current working directory.
check_for_previous_attempts()
{
	echo -n "Checking for previous validation attempts... "
	local output_found
	output_found=$(find "${wd}" -maxdepth 1 -type d -name \
	    "$(basename "${output_dir}")*" -print -quit)
	if [ "$output_found" != "" ]; then
		fail "Previous attempt at validation found:" \
		    "$(rp "${output_found}")" \
		    "You can remove it by running: '$0 clean'"
	fi
	output_found=$(find "${wd}" -maxdepth 1 -name "pftiii_validation_*" \
	    -a \! -name "pftiii_validation_images_*.tar.gz" -print -quit)
	if [ "${output_found}" != "" ]; then
		fail "Previous attempt at validation found:" \
		    "$(rp "${output_found}")" "" \
		    "You can remove it by running: '$0 clean'"
	fi

	okay
}

# Compile the validation driver.
compile()
{
	echo -n "Building... "

	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed>"
	fi

	local log="${output_dir}/compile.log"

	# cksum -a sha256 "../libpftiii/libpftiii.cpp" \
	#    "../include/pftiii.h" "src/CMakeLists.txt" \
	#    "src/pftiii_validation.cpp" \
	#    "src/pftiii_validation_data.h" \
	#    "src/pftiii_validation.h" \
	#    "src/pftiii_validation_utils.h" \
	#    "validate" > \
	#    CHECKSUMS

	# Check checksums
	echo "Source checksums:" >> "${log}"
	if ! cksum --strict --check "${wd}/CHECKSUMS" >> "${log}"; then
		local msg="One or more validation source files appears to have "
		msg+="been modified. Refer to \"${wd}/CHECKSUMS\"."
		fail "${msg}"
	fi
	{
		echo
		cksum -a sha256 "${wd}/validate"
		echo
	} >> "${log}"

	if [ -n "${LD_LIBRARY_PATH}" ]; then
		local msg="You appear to have set the variable "
		msg+="LD_LIBRARY_PATH. This is something that you should not "
		msg+="do. Instead, ensure the RUNPATH of your core library is "
		msg+="set to \$ORIGIN."
		fail "${msg}"
	fi

	if [ -e "${lib_dir}"/libpftiii.so ]; then
		local msg="The library 'libpftiii.so' is in the directory "
		msg+="$(rp "${lib_dir}"). This script will build its own copy "
		msg+="of the library to ensure that modifications have not "
		msg+="been made, since doing so may cause issues during the "
		msg+="evaluation."
		warn "${msg}"

		echo -n "Still building... "
		rm -f "${lib_dir}/libpftiii.so"
		if [ -e "${lib_dir}/libpftiii.so" ]; then
			msg="This script could not overwrite your copy of "
			msg+="libpftiii.so."
			fail "${msg}"
		fi
	fi

	# Catch the case of hardcoding "../lib", etc. into library by always
	# linking against libs in a different directory
	local tmp_dir
	tmp_dir="$(mktemp -u -t pftiii_libs.XXXXXXXXXX)"
	mkdir -p "${tmp_dir}"
	cp -r "${lib_dir}" "${tmp_dir}/lib"
	lib_dir="${tmp_dir}/lib"
	if [ -d "${local_lib_dir}${move_suffix}" ]; then
		local msg="You have a directory named ${local_lib_dir}"
		msg+="${move_suffix}. Please remove or rename it."
		fail "${msg}"
	else
		if ! mv -n "${local_lib_dir}" "${local_lib_dir}${move_suffix}"
		then
			fail "Could not move ${local_lib_dir}"
		fi
		local_lib_dir="${local_lib_dir}${move_suffix}"
	fi

	tmp_dir="$(mktemp -u -t pftiii_configs.XXXXXXXXXX)"
	cp -r "${config_dir}" "${tmp_dir}"
	chmod -R -w "${tmp_dir}"
	config_dir="${tmp_dir}"
	if [ -d "${local_config_dir}${move_suffix}" ]; then
		move_back_dirs

		local msg="You have a directory named ${local_config_dir}"
		msg+="${move_suffix}. Please remove or rename it."
		fail "${msg}"
	else
		if ! mv -n "${local_config_dir}" \
		    "${local_config_dir}${move_suffix}"
		then
			fail "Could not move ${local_config_dir}"
		fi
		local_config_dir="${local_config_dir}${move_suffix}"
	fi

	# Compile
	echo "Compilation:" >> "${log}"
	local build_dir
	build_dir="$(mktemp -d -t pftiii_validation_build.XXXXXXXXXX)"
	if [ "${build_dir}" == "" ]; then
		fail "Could not create build directory."
	fi
	cd "${build_dir}" || fail "Could not change to build directory"
	if ! cmake \
	    -DCMAKE_INSTALL_PREFIX="$(dirname "${lib_dir}")" \
	    -S "${src_dir}" -B "${build_dir}" >> "${log}" 2>&1
	then
		local msg="Could not change back to previous directory"
		cd "${wd}" > /dev/null || fail "${msg}"
		fail "An error occurred during configuration. Please review:" \
		    "$(rp "${log}")"
	fi
	cd "${wd}" > /dev/null || fail \
	    "Could not change back to previous directory"
	if ! make -C "${build_dir}" VERBOSE=1 >> "${log}" 2>&1; then
		fail "An error occurred during compilation. Please review:" \
		    "$(rp "${log}")"
	fi
	if ! make -C "${build_dir}" install VERBOSE=1 >> "${log}" 2>&1; then
		fail "An error occurred during installation. Please review:" \
		    "$(rp "${log}")"
	fi
	echo >> "${log}"

	# Check that binary shows a dependency on the core library
	local core_lib
	if ! core_lib="$(get_core_library_name)"; then
		fail "Could not get core library name"
	fi

	if ! grep -q "${lib_dir}/${core_lib}" < <(ldd "${binary}"); then
		local msg="${core_lib} is not a dependency of the compiled "
		msg+="binary. The library was either renamed after being "
		msg+="built, or the binary is linking against a version of "
		msg+="${core_lib} from a directory outside of the validation "
		msg+="package. Please review:"
		fail "${msg}" "$(rp "${log}")"
	fi

	# Check for ORIGIN if using multiple libraries
	local num_libs
	num_libs="$(find "${lib_dir}" -name "lib*" -type f | wc -l)"
	if [ "${num_libs}" -gt 2 ]; then
		# RUNPATH preferred over RPATH
		local uses_rpath=0
		if readelf -d "${lib_dir}/${core_lib}" | grep -q RPATH; then
			uses_rpath=1
		fi
		if [ "${uses_rpath}" == "1" ]; then
			local msg="You are setting RPATH, but RUNPATH is "
			msg+="preferred for new development. Please consider "
			msg+="setting RUNPATH instead of RPATH."

			warn "${msg}"
			echo -n "Still building... "
		fi

		# Check for $ORIGIN in both RPATH and RUNPATH
		local origin_in_rpath=0
		if [ "${uses_rpath}" == "1" ]; then
			if readelf -d "${lib_dir}/${core_lib}" | \
			    grep RPATH | grep -q "\$ORIGIN"; then
				for p in $(readelf -d "${lib_dir}/${core_lib}" \
				    | grep RUNPATH | grep "\$ORIGIN" | \
				    cut -f 2 -d '[' | tr -d ']' | tr ':' ' ');
				    do
					if [ "${p}" == "\$ORIGIN" ] || \
					    [ "${p}" == "\$ORIGIN/" ]; then
						origin_in_rpath=1
						break
					fi
				done
			fi
		fi
		local origin_in_runpath=0
		if readelf -d "${lib_dir}/${core_lib}" | \
		    grep RUNPATH | grep -q "\$ORIGIN"; then
			for p in $(readelf -d "${lib_dir}/${core_lib}" \
			    | grep RUNPATH | grep "\$ORIGIN" | \
			    cut -f 2 -d '[' | tr -d ']' | tr ':' ' ');
			    do
				if [ "${p}" == "\$ORIGIN" ] || \
				    [ "${p}" == "\$ORIGIN/" ]; then
					origin_in_runpath=1
					break
				fi
			done
		fi

		if [ "${origin_in_rpath}" == "0" ] && \
		    [ "${origin_in_runpath}" == "0" ]; then
			local msg="You have supplied multiple libraries, but "
			msg+="${core_lib} does not have an RUNPATH of \$ORIGIN."
			msg+=" This may cause runtime issues, because the "
			msg+="location of libraries on NIST's systems will not "
			msg+="be laid out the same as in this validation "
			msg+="package and the only library explicitly linked "
			msg+="will be ${core_lib}."

			warn "${msg}"
			echo -n "Still building... "
		fi

		# Does it look like we're finding libraries elsewhere?
		if grep -q -v -e "=> /lib/x86_64-linux-gnu/" \
		    -e "/ld-linux-x86-64.so" -e "linux-vdso.so.1 " \
		    -e "=> /tmp/pftiii_libs." < \
		    <(ldd "${binary}"); then
			local msg="You may have required non-system libraries "
			msg+="that are being found in a location other than "
			msg+="the lib directory. Review the filtered "
			msg+="'ldd' output below for more information (please "
			msg+="report any false positives):"
			warn "${msg}"

			ldd "${binary}" | grep -v \
			    -e "=> /lib/x86_64-linux-gnu/" -e " /lib64/" \
			    -e "/ld-linux-x86-64.so" -e "linux-vdso.so.1 " \
			    -e "=> /tmp/pftiii_libs."

			echo

			echo -n "Still building... "
		fi
	fi

	# Suspected non libraries in library directory
	local non_libs
	non_libs="$(find "${local_lib_dir}" \! -name "lib*" -a \! \
	    -name README | wc -l)"
	if [ "${non_libs}" -gt 0 ]; then
		local short_libdir
		short_libdir="$(rp "${local_lib_dir}")"
		short_libdir="$(basename "${short_libdir}" ${move_suffix})"
		local short_configdir
		short_configdir="$(rp "${local_config_dir}")"
		short_configdir="$(basename "${short_configdir}" ${move_suffix})"

		local msg="You have files in \"${short_libdir}\" that don't "
		msg+="appear to be libraries. That's fine, but are you sure "
		msg+="they don't belong in \"${short_configdir}\" instead?"

		warn "${msg}"
		echo -n "Still building... "
	fi

	# Log some extra compilation information that may be useful in helping
	# to debug future issues
	{
		echo "Linked libraries:"
		find "${lib_dir}" -type f \! -name README -exec md5sum {} \;
		echo

		echo "Configs present:"
		find "${config_dir}" -type f \! -name README -exec md5sum {} \;
		echo

		echo "Ubuntu Version:"
		grep "VERSION=" /etc/os-release | cut -f 2 -d '=' | tr -d '"'
		echo

		echo "ldd output of binary:"
		ldd "${binary}"
		echo

		echo -n "Dynamic section of binary:"
		readelf -d "${binary}"
		echo

		echo "Dynamic section of attached libraries:"
		while read -r i; do
			echo -n "readelf -d ${i}"
			readelf -d "${i}" 2>&1
			echo
		done < <(find "${lib_dir}" -type f -name "lib*")

		echo "CPU Info = "
		if [ -e /proc/cpuinfo ]; then
			cat /proc/cpuinfo
		else
			echo "NA"
		fi

		echo -n "MemTotal = "
		if [ -e /proc/meminfo ]; then
			grep "MemTotal" /proc/meminfo | cut -f2 -d ':' | xargs
		else
			echo "NA"
		fi

		echo "Validation properties:"
		echo "Validation Version = ${validation_version}"
		echo "Random Seed = $1"

		echo -n "Image Version = "
		cat "${wd}/${validation_image_dir}/VERSION"
	} >> "${log}"

	okay
}

check_api_level()
{
	echo -n "Checking API version... "

	# If API level is incorrect, text is printed to stderr on execution
	local tempfile
	tempfile="$(mktemp)"
	local output
	output=$(${binary} 2> "${tempfile}")
	if [ "$(grep -c "Incompatible " "${tempfile}")" -ne 0 ]; then
		output=$(<"${tempfile}")
		rm "${tempfile}"
		fail "${output}"
	fi

	rm "${tempfile}"
	okay
}

# Remove files from previous validation attempts.
clean_previous_attempts()
{
	echo -n "Cleaning previous attempts... "
	rm -rf "${bin_dir}"
	if [ -d "${bin_dir}" ]; then
		fail "Failed to remove" "${bin_dir}"
	fi

	rm -rf "${output_dir}"
	if [ -d "${output_dir}" ]; then
		fail "Failed to remove" "${output_dir}"
	fi

	rm -f "${lib_dir}/libpftiii.so"
	rm -rf "${wd}/include"

	find /tmp -maxdepth 1 -type d -name 'pftiii_libs.*' -exec rm -rf {} \;
	find /tmp -maxdepth 1 -type d -name 'pftiii_configs.*' \
	    -exec chmod +w {} \;
	find /tmp -maxdepth 1 -type d -name 'pftiii_configs.*' -exec rm -rf {} \;
	find /tmp -maxdepth 1 -type d -name 'pftiii_validation_build.*' \
	    -exec rm -rf {} \;

	local org_name
	if ! org_name="$(get_organization_name)"; then
		fail "Could not get organization name."
	fi

 	rm -rf "${wd}"/pftiii_validation_"${org_name}"_*
	if [ "$(find "${wd}" -name \
	    "pftiii_validation_${org_name}_*" | wc -l)" != "0" ];
	    then
	    	fail "Failed to remove some output. Please delete it manually."
	fi

	okay
}

# Log identification information to a log file.
record_identification_information()
{
	local log="${output_dir}"/id.log

	echo "Core Library = $(get_core_library_name)" >> "${log}"
	chmod -w "${config_dir}"
	if ! ${binary} -i -z "${config_dir}" >> "${log}"; then
		local msg="Your algorithm did not exit cleanly when retrieving "
		msg+="version information. Please check your implementation of "
		msg+="getIdentification()."
		fail "${msg}"
	fi
	chmod +w "${config_dir}"

	# Check that version in filename matches value compiled within
	local filename_vers
	filename_vers="$(get_lib_version)"
	filename_vers="$(tr '[:lower:]' '[:upper:]' <<< "${filename_vers}")"

	local compiled_version
	compiled_version=$(grep "^Version = 0x" "${log}")
	compiled_version="${compiled_version//Version = 0x/}"
	compiled_version="$(tr '[:lower:]' '[:upper:]' <<< \
	    "${compiled_version}")"

	if [ "${filename_vers}" != "${compiled_version}" ]; then
		local msg="The version specified in your library's filename ("
		msg+="${filename_vers}) and the version in compiled within "
		msg+="you library (${compiled_version}) are not the same.";
		fail "${msg}"
	fi

	check_cbeff_dependencies
}

# Run an arbitrary test operation on the compiled binary
run_operation()
{
	if [ $# -ne 3 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed> <function> <op_flag>"
	fi

	local seed=$1
	local function=$2
	local op_flag=$3

	echo -n "Testing ${function}()... "

	# We want to fork regardless to be sure that implementations can handle
	# forking, but we don't need to spawn a ton of processes either.
	forks=$(( $(nproc --all) > 4 ? 4 : 2 ))

	local log
	log="${output_dir}"/run-$(tr -c -d '[:alnum:]' <<< \
	    "${function}").log
	local command="${binary} ${op_flag} -r ${seed} -f ${forks} "
	command+="-z ${config_dir}"
	echo "${command}" >> "${log}"
	chmod -w "${config_dir}"
	if ! ${command} >> "${log}" 2>&1; then
		local msg="An error occurred during tests of ${function}. "
		msg+="Please investigate:"
		fail "${msg}" "${log}"
	fi
	chmod +w "${config_dir}"

	# Check for runtime error messages
	if [ "$(wc -l < "${log}")" != "1" ]; then
		local msg="Unexpected output was logged during test of "
		msg+="${function}. Please review:"
		fail "${msg}" "$(rp "${log}")"
	fi

	okay
}

# Check logs for potential errors
check_logs()
{
	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <function>"
	fi
	operation="${1}"

	echo -n "Checking ${operation}() logs... "
	merge_logs "$(tr -c -d '[:alnum:]' <<< "${operation}")"
	check_log_counts "${operation}"
	check_unknown "${operation}"
	if check_variable_resolution "${operation}"; then
		okay
	fi
}

# Check the segmentation logs for the appropriate number of lines.
check_log_counts()
{
	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <function>"
	fi
	func="${1}"

	local expected_num_lines=0
	if [ "${func}" == "${create_func}" ]; then
		expected_num_lines=910
	elif [ "${func}" == "${compare_func}" ]; then
		expected_num_lines=1289
	fi

	local log="${output_dir}"/${func}.log
	if ! [ -e "${log}" ]; then
		fail "An expected log was not generated." "${log}"
	fi

	if [ "$(wc -l < "${log}")" -ne "${expected_num_lines}" ]; then
		local msg="A log does not have the expected number of lines "
		msg+="inside. Please review:"
		fail "${msg}" "$(rp "${log}")"
	fi
}

# Merge forked logs into a single file.
merge_logs()
{
	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <log_prefix>"
	fi

	local log_prefix="${1}"

	exists=$(find "${output_dir}" -type f -name "${log_prefix}-*" \
	    -print -quit)

	if [ "${exists}" == "" ]; then
		fail "Could not merge ${log_prefix} logs."
	fi

	# Get the header
	local log="${output_dir}/${log_prefix}.log"
	head -n 1 "${exists}" >> "${log}"

	# Merge the logs, minus the header
	while read -r f; do
		tail -n +2 "${f}" >> "${log}"
		rm "${f}"
	done < <(find "${output_dir}" -type f -name "${log_prefix}-*")

	# Sort, ignoring the header
	(head -n 1 "${log}" && tail -n +2 "${log}" | sort) > "${log}.sort"
	rm "${log}"
	mv "${log}.sort" "${log}"
}

get_final_output_name()
{
	local name="pftiii_validation_"
	if ! name+="$(get_organization_name)"; then
		fail "Could not get organization name."
	fi
	name+="_"
	if ! name+="$(get_lib_version)"; then
		fail "Could not get library version."
	fi

	echo "${name}"
}

# Generate the name of the validation tarball.
get_tarball_name()
{
	echo "$(get_final_output_name).tar.xz"
}

# Make a tarball of all libraries and logfiles to send to NIST.
make_tarball()
{
	echo -n "Creating validation submission... "

	local final_output_name
	if ! final_output_name="$(get_final_output_name)"; then
		fail "Could not get final output name."
	fi
	local final_output_path="${wd}/${final_output_name}"
	local tar_file="${final_output_name}.tar.xz"

	if ! mv -n "${output_dir}" "${final_output_path}" > /dev/null 2>&1; then
		fail "Could not rename $(rp "${output_dir}")"
	fi
	if ! cp -pr "${local_lib_dir}" "${final_output_path}"; then
		fail "Could not copy $(rp "${local_lib_dir}")"
	fi
	if ! cp -pr "${local_config_dir}" "${final_output_path}"; then
		fail "Could not copy $(rp "${local_config_dir}")"
	fi

	# Remove unnecessary files
	if ! find "${final_output_path}" \( -type f -name 'libpftiii.so' -o \
	    -name 'README' \) -exec rm -f {} \;; then
		fail "Could not remove unnecessary validation files"
	fi

	if ! tar -C "${wd}" -c -J -f "${tar_file}" "${final_output_name}" > \
	    /dev/null 2>&1; then
		fail "There was an issue creating the validation tar file."
	fi

	# Update globals
	output_dir="$(dirname "${output_dir}")/$(get_final_output_name)"

	okay "${tar_file}"
}

# Print success message.
print_final_success()
{
	local tar_file
	if ! tar_file="$(get_tarball_name)" ;then
		fail "Could not get final output name."
	fi
	echo
	font_green

	local msg="You have successfully completed your part of PFT III "
	msg+="validation. Please sign and encrypt the file listed below (run "
	msg+="'${0} encrypt' for an example)."
	box "${msg}" 80 '=' '|' 'l' 1 0
	boxline
	box "${tar_file}" 80 '=' '|' 'c' 0 0
	boxline

	msg="Please upload both ${tar_file}.asc and your public key via "
	msg+="https://pages.nist.gov/pft/upload"

	box "${msg}" 80 '=' '|' 'l' 0 1
	font_reset

	echo
	msg="Please review the marketing and CBEFF information compiled into "
	msg+="your library to make sure it is correct:"
	font_yellow
	box "${msg}" 80 '=' '|' 'l' 1 0
	boxline
	local line_num=0
	while read -r i; do
		k=$(cut -f1 -d= <<< "${i}" | sed 's/ \{1,\}$//')
		v=$(cut -f2 -d= <<< "${i}" | sed -e 's/^ //' -e 's/ \{1,\}$//')
		if [ "${v}" == "" ]; then
			v="Unspecified"
		fi
		box "${k}:" 80 '=' '|' 'l' 0 0
		if [ ${line_num} -ne 5 ]; then
			box "-> ${v}" 80 '=' '|' 'l' 0 0
			boxline
		else
			box " -> ${v}" 80 '=' '|' 'l' 0 1
		fi
		line_num=$(( line_num + 1 ))
	done < <(head -n 9 "${tar_file//.tar.xz/}/id.log" | tail -n 6)
	font_reset

	echo
}

print_encryption()
{
	local tar_file
	if ! tar_file="$(get_tarball_name)"; then
		tar_file="pftiii_validation_nullimpl_0001.tar.xz"
	fi

	# Sign + encrypt example
	echo "Example of signing and encrypting with GnuPG:"
	echo "  gpg --output ${tar_file}.asc \\"
	echo "      --default-key <!-- YOUR EMAIL ADDRESS --> \\"
	echo "      --recipient <!-- YOUR EMAIL ADDRESS --> \\"
	echo "      --recipient pft@nist.gov \\"
	echo "      --armor --sign --encrypt ${tar_file}"
	echo

	# Extract public key example
	local lib_name
	if ! lib_name="$(get_core_library_name)"; then
		lib_name="libpftiii_nullimpl_0001.so"
	fi
	lib_name="$(basename "${lib_name}" .so)"
	echo "Example of extracting public key with GnuPG:"
	echo "  gpg --output ${lib_name}_public_key.asc \\"
	echo "      --armor --export <!-- YOUR EMAIL ADDRESS -->"
	echo

	# Export key fingerprint example
	echo "Example of extracting fingerprint from public key with GnuPG:"
	echo "  gpg --fingerprint <!-- YOUR EMAIL ADDRESS --> | grep '^ '"
}

# Print instructions to the console
print_instructions()
{
	echo "$0 clean"
	echo -n " - Restores validation directory to original state, removing "
	echo "any previous "
	echo "   output, but leaving copied libraries and configurations."
	echo
	echo "$0 encrypt"
	echo " - Print sample signing and encryption instructions for GnuPG."
	echo
	echo "Instructions"
	echo "============"
	echo " 1. Copy required files:"
	echo -n "    a. Place all needed libraries in 'lib/', including your "
	echo "properly named "
	echo "          PFT III core library."
	echo "    b. Place any needed runtime configuration files in 'config/'."
	echo " 2. Run './validate'."
	echo "    a. Successful? Sign and encrypt the generated archive."
	echo "    b. Unsuccessful? Work to resolve the listed errors, run"
	echo "       './validate clean', and repeat these steps."
	echo -n " 3. Upload the signed and encrypted file along with your "
	echo "public key to"
	echo "    https://pages.nist.gov/pft/upload"
}

# Print message when validation version couldn't be checked
print_couldnt_check_version()
{
	# URL where information about the validation package can be found
	local info_url="https://github.com/usnistgov/pft/tree/master/pftiii/"
	info_url+="validation"

	# URL where the version of the validation driver can be found
	local vers_url="https://github.com/usnistgov/pft/tree/master/pftiii/"
	vers_url+="validation/VERSION"

	local msg="IMPORTANT: This script was unable to check, so please "
	msg+="ensure that you are using the latest version of the PFT III "
	msg+="validation package before submitting. Using the latest version "
	msg+="of the validation package is a requirement. You are currently "
	msg+="running with version ${validation_version}."

	font_lightred
	box "${msg}" 80 '=' '|' 'l' 1 0
	boxline
	box "Information:" 80 '=' '|' 'l' 0 0
	box "${info_url}" 80 '=' '|' 'l' 0 0
	box "Version:" 80 '=' '|' 'l' 0 0
	box "${vers_url}" 80 '=' '|' 'l' 0 0
	box "Download:" 80 '=' '|' 'l' 0 0
	box "${validation_dl_url}" 80 '=' '|' 'l' 0 1
}

# Prevent against possible issues when not using GNU realpath
check_wd()
{
	if [ "${wd}" == "" ]; then
		msg="The directory containing \"validate\" could not be found, "
		msg+="possibly because you are not using GNU realpath under "
		msg+="Ubuntu. If you are, please report an issue on the "
		msg+="PFT GitHub repository."
		fail "${msg}"
	fi
}

# Check that participant did not skip image with unknown metadata
# @param operation
check_unknown()
{
	local unknown_img="00002579_S_265x431_500_29_00_00.gray"

	local line
	line=$(grep "${unknown_img}" "${output_dir}/${1}.log")
	if [ "${1}" == "${create_func}" ]; then
		if [ "$(cut -f3 -d, <<< "${line}")" != "0" ]; then
			local err="Extracting features from images with "
			err+="unknown metadata is required. Please examine "
			err+="creation log entry for name = \"${unknown_img}.\""
			fail "${err}" "${output_dir}/${1}.log"
		fi
	else
		if [ "$(cut -f4 -d, <<< "${line}")" != "0" ]; then
			local err="Unable to compare a template generated from "
			err+="an image with no metadata. Please examine "
			err+="comparison log entry for probe name = "
			err+="\"${unknown_img}.\""
			fail "${err}" "${output_dir}/${1}.log"
		fi
	fi
}

# Check that participant did not fail on all images != 500 or 1000 PPI
check_variable_resolution()
{
	local var_res="_100_ _250_ _300_ _333_ _600_"
	local success=0
	local failure=0

	for res in ${var_res}; do
		while read -r line; do
			if [ "${1}" == "${create_func}" ]; then
				if [ "$(cut -f3 -d, <<< "${line}")" == "0" ] \
				    && \
				    [ "$(cut -f5 -d, <<< "${line}")" == "0" ];
				    then
					success=$(( success + 1 ))
				else
					failure=$(( failure + 1 ))
				fi
			else
				if [ "$(cut -f4 -d, <<< "${line}")" == "0" ];
				then
					success=$(( success + 1 ))
				else
					failure=$(( failure + 1 ))
				fi
			fi
		done <<< "$(grep "${res}" "${output_dir}/${1}.log")"
	done

	if [ "${failure}" -eq 0 ]; then
		return 0
	fi

	# Maybe participant had an issue with some images
	local percentage=$(( (failure * 100) / (success + failure) ))
	if [ "${percentage}" -eq 0 ]; then
		return 0
	fi

	local all_res+="PFT III reports results on images of variable "
	all_res+="resolutions and algorithms are expected to deal with all "
	all_res+="resolutions natively."

	local err=""
	if [ "${1}" == "${create_func}" ]; then
		err+="Attempts to create a template from an image that was not "
		err+="acquired at a resolution of 500 or 1 000 PPI failed."
	else
		err+="Attempts to compare templates generated from images not "
		err+="acquired at a resolution of 500 or 1 000 PPI failed."
	fi

	if [ "${percentage}" -lt 25 ]; then
		warn "${err} ${all_res}" "${output_dir}/${1}.log"
		return 1
	else
		fail "${err} ${all_res}" "${output_dir}/${1}.log"
	fi
}

# Check that all required CBEFF information appears to be set
check_cbeff_dependencies()
{
	echo -n "Checking CBEFF algorithm identifiers for product owners... "
	local log="${output_dir}"/id.log
	local key=""
	local key_dependent=""

	key="CBEFF Feature Extraction Algorithm Identifier"
	key_dependent="CBEFF Feature Extraction Algorithm Product Owner"
	value=$(grep "${key}" "${log}" | cut -f2 -d= | tr -d '[:space:]')
	value=${value//0x/}
	if [ "${value}" != "" ]; then
		value=$(grep "${key_dependent}" "${log}" | cut -f2 -d=)
		value=$(tr -d '[:space:]' <<< "${value}" | sed -e 's/0x//')
		if [ "${value}" == "" ] || [ "${value}" == "0000" ]; then
			local err="Setting ${key} requires you to also set "
			err+="${key_dependent}"
			fail "${err}"
		fi
	fi

	key="CBEFF Comparison Algorithm Identifier"
	key_dependent="CBEFF Comparison Algorithm Product Owner"
	value=$(grep "${key}" "${log}" | cut -f2 -d= | tr -d '[:space:]')
	value=${value//0x/}
	if [ "${value}" != "" ]; then
		value=$(grep "${key_dependent}" "${log}" | cut -f2 -d=)
		value=$(tr -d '[:space:]' <<< "${value}" | sed -e 's/0x//')
		if [ "${value}" == "" ] || [ "${value}" == "0000" ]; then
			local err="Setting ${key} requires you to also set "
			err+="${key_dependent}"
			fail "${err}"
		fi
	fi

	okay
}

###############################################################################
###############################################################################
###############################################################################

# Move directories back on SIGINT
trap move_back_dirs INT

check_wd
cd "${wd}" || exit 1
read -r validation_version < "${wd}"/VERSION
print_header

if [ "${#}" -ne 0 ]; then
	if [ "${1}" == "clean" ]; then
		clean_previous_attempts
		exit
	elif [ "${1}" == "encrypt" ]; then
		print_encryption
		exit
	elif [ "${1}" == "help" ]; then
		print_instructions
		exit
	else
		echo "Usage: ${0} [clean|encrypt|help]"
		print_instructions
		exit 1
	fi
else
	# Quick check to see if it looks like we're fresh
	if ! core_library_present; then
		print_instructions
		exit
	fi
fi

# Pre-check
check_required_packages
check_for_previous_attempts
check_validation_version; validation_version_checked=$?
check_os
check_for_images
check_image_versions
check_library
check_environment

# Run
mkdir -p "${output_dir}" || exit 1
log_canaries
seed="$(random_number)" || exit 1
compile "${seed}"
check_api_level
record_identification_information
run_operation "${seed}" "${create_func}" "-e"
check_logs "${create_func}"
run_operation "${seed}" "${compare_func}" "-c"
check_logs "${compare_func}"

# Cleanup
move_back_dirs
make_tarball

# Notifications
if [ "${validation_version_checked}" -eq "0" ]; then
	echo
	print_couldnt_check_version
fi
print_final_success
print_footer "${start_sec}"
